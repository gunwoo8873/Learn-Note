# Desain Pattern

## Desain Paatern이란?
디자인 패턴은 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 `규약` 형태로 만들어 놓은 것을 의미한다

## 1. 싱글톤 패턴[Singleton Pattern]
하나의 `클래스[Class]`에 오직 하나의 `인스턴스[Instance]`만 가지는 패턴이며, 하나의 클래스를 기반으로 여러 갱의 개별적인 인스턴스를 만들 수 있지만, 그렇게 하지 않고 하나의 클래스를 기반으로 단 하나의 인스턴스를 만들어 이를 기반으로 로직을 만드는 데 쓰이고, 주로 Database 연결 모듈에 많이 사용한다.

### 1-2. 싱글톤 패턴 장단점
---
* **장점**
  * 하나의 인스턴스를 생성하고 해당 인스턴스를 다른 Module들이 공유하여 사용하기 때문에 인스턴스 생성 비용이 감소한다.

* [**단점**](#1-3-싱글톤-패턴-단점)
  * 하나의 인스턴스를 생성하고 사용하는 Module들이 늘어날 수록 의존성이 상승한다.

### 1-3. 싱글톤 패턴 단점
---
`TDD[Test Driven Development]`에 대한 문제가 발생할 가능성이 크며, 주로 TDD를 할 땐 단위 테스트를 위한 방식이나, 서로 독립적인 테스트여야 하기 때문에 어떤 순서로든 실행이 가능해야 한다. 하지만 미리 생성된 하나의 Instance를 기반으로 구현하는 패턴이므로 각 테스트마다 `독립적인` 인스턴스를 만들기 어렵다. 또한 싱글톤 패턴은 사용하기 쉽고 실용적이지만 모듈간의 결합을 강하게 만들 수 있다는 단점이 존재한다. 이경우 `의존성 주입[DI, Dependency Injection]`을 통해 모듈간의 완화로 해결할 수 있다.

* 요약
  * Instance를 기반으로 구현하는 패턴이므로 독립적인 인스턴스를 생성이 어렵다.
  * 모듈간의 결합을 강하게 만들 수 있다.

### 1-3-2. 의존성 주입[Dependency Injection] 장단점
---
* **장점**
  * Module들을 쉽게 교체할 수 있는 구조화가 되어 테스트에 적합하며 쉽게 마이크레이션이 가능하다.
  * 구현할 때 추상적인 레이어를 넣고 이를 기반으로 구현체를 넣어 주기 때문에 애플리케이션 의존성 방향이 일관성을 띈다.
  * 애플리케이션[Application]을 쉽게 추론할 수 있으며, 모듈 간의 관계들이 명확해진다.

* **단점**
  * 모듈들이 분리되어 클래스 수가 증가해 복잡성이 상승하고 런타임 페널티가 생길 가능성이 크다.

### 1-3-3. 의존성 주입[Dependency Injection] 원칙
---
상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않도록 하고, 추상화에 의존성과 추상화는 세부 사항에 의존하지 말아야한다.

### Singleton Pattern Code
* Go
  ```go
  type Obj struct {
	  a int
  }

  var (
    instance *Obj
    once     sync.Once
  )

  func GetInstance() *Obj {
    once.Do(func() {
      instance = &Obj{a: 1}
    })

    return instance
  }

  func main() {
    objA := GetInstance()
    objB := GetInstance()

    fmt.Println(objA == objB)
  }
  ```

## 2. 팩토리 패턴[Factory Pattern]
객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화환 패턴이자 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 틀을 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴이다. 상위 클래스와 하위 클래스가 분리되어 상위 클래스에서는 인스턴스 생성 방식에 대해 확인할 필요가 없기 때문에 유연성을 부여할 수 있다. 그리고 객체 생성 로직이 별도로 존재하여 코드를 리팩터링 작업을 진행하더라도 특정 부분만 수정하면 되기 때문에 유지 보수성이 증가한다.

### Fectory Pattern
* Go
  ```go
  type Obj struct {
    name string
  }

  func (o *Obj) GetMethod() string {
    return o.name
  }

  func main() {
    obj := Obj{name: "User"}
    fmt.Println(obj.GetMethod())
  }
  ```

## 3. 전략 / 정책 패턴[Strategy / Policy Pattern]
객체의 성격을 바꾸고 싶은 경우 직접적으로 수정하지 않고 전략이라 칭하는 캡슐화를 컨텍스트 안에서 변경함으로써, 상호 교체가 가능하게 만드는 패턴이다.

## 4. 옵저버 패턴[Observer Pattern]
주체가 어떤 객체[Subject]의 상태 변화를 관찰하다가 상태 변화가 있을 경우 메서드등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴이다. 주로 이벤트 기반 시스템에 사용하며 MVC[Model-View-Contoller]패턴에도 사용된다.
> 주체 : 객체의 상태 변화를 관찰하는 관찰자  
> 옵저버 : 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 추가 변화 사항이 생기는 객체